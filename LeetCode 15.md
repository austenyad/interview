## LeetCode 15

### 解法一：递归之分治

S 中的每个字母就是两种可能 **选中** 或 **不选中**。我们用递归的常规思路，将大问题化成小问题，也就是分治的思想。

如果我们求 `S[0,S_len - 1]` ，中能选出多少个 `T[0,T_len - 1]`，个数记为 `n` 。那么分两种情况，

*  `S[0] == T[0]` ，需要知道两种情况

  * 从 S 中选择当前的字母，此时 S 跳过这个字母，T 也跳过这个字母。

  去求 `S[1,S_len - 1]`中能选出多少个 `T[1,T_len - 1]`，记为 `n1`

  * S 不选当前字母，此时 S 跳过这个字母，`T` 不跳过这个字母。（T 就不能跳过）

  去求 `S[1,S_len - 1]` 中能选出多少个 `T[0,T_len - 1]` ,个数记为 `n2`

* `S[0] != T[0]`

  S 只能不选当前字母，此时 S 跳过这个字母，T 不跳过字母

  去求 `S[1,S_len - 1]` 中能选出多少个 `T[0,T_len - 1]`，这个记为 `n1`

也就是说如果求 `S[0,S_len - 1]` 中能选出多少个 `T[0,T_len - 1]` ，个数记为 n。转换为数学公式就是

`if(S[0] == T[0])`

```java
if(S[0] == T[0]){
    n = n1 + n2;
}else{
    n = n1;
}
```

