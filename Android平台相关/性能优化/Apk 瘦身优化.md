### Apk 瘦身优势

* 最主要的是转换率：用户的下载转换率，用户在市场找同一类的 App，Apk 大小也是用户决定是否要下载的，重要影响因素。包体积约小下载的就会多。
* 头部 App 都有 Lite 版本：许多大型 App，一般都有个一 Lite 版本，这也是考虑率到转换率的因素
* 渠道合作商要求：手机 App 预装，要就比较高。

### Apk 的组成

1）、代码相关：classes.dex

2)、资源相关：res、asserts、resources.arsc

3)、So 相关：lib

### Apk 分析的方式

1）、ApkTool ，反编译工具

官网：https://ibotpeaches.github.io/Apktool/

 具体的反编译命令：`apktool d xx.apk`

2)、Analyze Apk: Android Stuido 2.2 之后的自带工具

* 查看 Apk 组成，以及各个组成大小，占比
* 查看 dex 文件组成
* Apk 对比（不同版本的 Apk 进行对比分析）

3）、 https://nimbledroid.com/   App 性能分析网站   

* 可以显示出来 **文件大小以及文件排行榜**
* dex 文件中的方法数、三方SDK 方法树
* 告诉 **App启动时间、内存等** 方面的分析数据

4）、Android-classyshark: 二进制检查工具  http://github.com/google/android-classyshark

* 它可以**浏览任何的 Android 可执行文件，并且显示出信息**。比如说：类的接口，成员变量等。

* 支持多种格式： Apk、Jar、Class、So 等。包括 库、可执行文件：.dex、.arr、.jar、.Apk，以及所有的 Android 二进制 xml。

## 代码相关优化

代码混淆

三方库处理

移除无用代码



### 代码混淆

花指令，将计算机程序的代码转换 **成功能上等价但改变形式**，将代码转换成难以阅读和理解的形式。

代码混淆的方法主要有三种：

1. 将代码中的各个元素（比如说类、变量、函数等）改写成无意义的名字。比如说将 Context 转换成单个的字母 a ，这个反编译的人很难去根据名字来猜测代码的用途。
2. 重新代码中的部分逻辑，将它变成功能上等价，但是确实难以理解的形式。比如说我们可以改变循环的指令，结构体，精简中间变量等。**CPU 锁屏？**
3. 打乱代码的格式。比如说多加一些空格，删除一些空格，或者是将一行代码写成多行，或者将多行代码改成一行

 使用方式：

Android SDK Tools 里面，集成了 **Proguard 工具**，它是一个免费的 Java 类文件处理工具，对代码进行压缩、混淆、优先校验功能的工具。

* 它可以检测和移除未使用到的类、方法、字段，优化字节码，并且移除未使用的指令和冗余代码，最后它还会将 类名、方法、字段 它们的名词改成简短的无意义的名字。
* 增加代码被反编译的难度，一定程度上保证代码的安全性。

1）、首先要做项目的 **build.gradle**  中来设置 **minifyEnabled** 为 **true** 。**记好在 release 下打开混淆。**  

2）、然后在项目的 **proguard-rules** 中配置相应的规则即可。

### 三方库处理

1)、将基础库统一

2)、选用更小的库，可以通过 Android Sutido 插件 **Methods Count**，它会在 build.gradle 中显示出引入的三方库的方法数。

3)、对于三方库，仅仅引入项目中所需要的部分代码：Fresco 的 webp 支持。现在很多三方库代码结构设计的非常好，比如说 Fresco 它将图片加载的各个能力，比如说 webp、gif 进行的剥离，这些库又处于单独的库当中，如果说我们只需要 Fresco 的 webp 功能，就可以移除 Fresco 除了 webp 以为的其他子类库，这样引入的库就小了。Apk 大小也就小了。

如果引入的第三库，本身对功能没有进行剥离，那么就需要我们对源码进行修改，自己对代码功能进行剥离。

### 移除无用代码

实际的项目开发过程当中，经常的问题是 **业务代码只增不减** 的情况，产品同学他每个版本都在加功能，但是很少砍功能，所以说每个版本加一点代码，那么包体积只会越来越大。这个时候想删一些功能，发现其实也是不好删的，因为代码可能太多，你根本就不敢删，你并不确定哪些类，哪些图片是不是真的没有人用了。尤其是项目特别大的时候，业务逻辑非常多，没有人能说清楚这个类或资源一定不用了。这种情况非常的普遍也非常的头疼。

使用 Aop：

1)、对于 Activity ，只需要在每一个 onCreate 方法当中加上统计即可，然后到了线上如果有统计，那么说明 Activity 还在被使用，对于哪些不是 Activity 的类，我们可以利用 Aop 的方式来切它的构造函数，一个类如果它被使用，哪它的构造函数一定会被调用。**这种方式对于的我们业务代码的瘦身非常有用。**



## 资源瘦身

## So 文件瘦身

So 是 Android 上的动态链接库（加解密算法，音视频库）

So 是 机器可以直接运行的机器码，Android 开发的过程中有时候 Java 代码并不满足需求，比如说一些加解密算法，或者是音视频编解码功能，这个时候就必须通过 C/C++ 实现。

在使用 So 文件的时候就需要适配市面上不同的 CPU 架构，目前 Android 一共支持七种类型的 CPU 架构，比如常见的 **armv7、armv5、x86 等，理论上来说对应 CPU 架构的 so 文件执行效率更高**，但是这样会导致 lib 目录下存放着各个 CPU 架构的 So 文件，Apk 的体积也就是自然更大了。

我们需要对 lib 目录进行缩减，在 app 的 build.gradle 文件中 配置 **abiFilters: 设置支持的 So 架构，一般情况下我们留下只留下 armeabi 目录就可以了，armeabi 可以兼容别的平台下的 So,但是性能上会有所损坏，失去对特定平台的优化**

#### 更优的方案

理论上来说，对应架构的 CPU 的 so 文件它的执行效率是更高的，只是它的代价非常的大，增加的包体积不能接受。

我们可以取一个折中的方案，我们可以对性能敏感的模块，它使用的 so 我们都放到 armeabi 当中，我们将它随着 Apk 发出去，然后在代码当中判断设备的 CPU 类型，根据手机的不同 CPU 架构来加载对于的 对应架构so 文件。微信就是这么做的。

1.

```java
String abi = "";
if(Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOPO){
	abi = Build.CPU_ABI;
}else{
	abi = Build.SUPPORTED_ABIS[0];
}

if(TextUtils.equals(abi,"ARMv7")){
	//加载特定平台的 so
}else{
	正常加载
}
```

2.

部分 so 使用动态下发的方式来加载

3. 通过插件化方案对代码进行调整





面试：

* 怎么降低 Apk 包体积到下

在项目的初期我们只是按照需求不停的给 App 加功能，没有相应的规范，UI 给我们的图片都是没有经过压缩的图片，长期的累计导致我们的包体积越来越大，到了项目稳定期的时候，我们对各自运营数据进行考核，Apk 的体积大小影响了用户下载包体积的意愿，于是我们开始着手做包体积的优化，我们采用的是 Android Sutdio 自带的 AnanlyZer Apk ，做的包体积分析

主要是从

 代码

针对于代码我们首先使用 proguard 工具，进行了混淆，它将程序代码转换成功能相同但是不容易理解的形式，比如说将一个很长的类转换为一个字母a，同时这样让代码更加安全，

我们将项目中使用的第三方库进行了统一，比如说图片库网络库，数据库、工具类整合，保证项目中出现功能相同但实现不一样的代码，同时内部进行了规范意识，在引入第三方库的时候需要考虑它的大小，方法数等，而其如果是只需要一个很大库的小功能，那我们就来修改源码，只引入部分代码即可

我们对项目中的无用代码进行了删减，我们使用 Aop 的方式统计那些 Activity，以及 Fragment，在真实的场景下没有用户使用，这样就可以删除掉了，对于那些不是 Activity/Fragment 的代码，我们们切了很多类的构造函数，这样就可以统计出来这些类用没有被调用到

对于代码的瘦身效果做下来不是很明显

资源

移除了项目当中冗余的资源文件，然后做了资源图片的压缩和 webp 转换，还做了资源混淆，让冗余的资源名称换成简短的名字，资源压缩的效果要比代码瘦身的效果好的多

so库

首先我们只保留 armeabi 这个目录，它可以兼容别的 CPU 架构，这个一点优化效果非常的明显，异常了被的架构的CPU适配之后，我们做了对于项目中网络库的参数加解密我们为了保证网络的性能不受影响，我们将这个模块使用到的 被的架构的 so，都加到了 armeabi 目录下，然后在代码当中做动态判断，如果是别的CPU架构，我们就动态的加载对应的架构的 so 文件，这样既减少了包体积，同时也达到了性能最佳

对于整个是瘦身效果 so 文件是最明显的。 

* Apk 瘦身问题如何实现长效治理，尽量减少人工的干预，这个问题在项目变大之后它一定会暴露出来，如果每个版本都需要手动的做一遍优化，这实际上是不可能的

  插件化构造/ci 流程。

  





 

