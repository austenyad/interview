## 怎么控制被依赖对象的生命周期？

> 依赖类：需要依赖其他对象的类，称为 Client 类
>
> 被依赖类：Client类要依赖的外部对象，称为 Dependency 类

在程序中，一个类的对象它的存活时间，完全是可以由程序员控制的。比如，单例对象它的存活时间是跨越应用的整个生命周期。再或者类 类 B 依赖类 A 的对象，那么对于类 A 来讲它的声明周期是与类 B 相同的，当类 B 被回收时类 A 的生命就终结了。只要定义的依赖对象的生命周期，那么你在它的生命周期类，它的实例对象只有一个。前面说了，对于单例对象不管在程序的任何地方获取它，它的对象都是一个，就是因为它的生命是伴随着应用的存活而存活的。那么对于生命周期范围更小的对象也一样，只不过它伴随着 Client 的存活而存活。

> 可能你对于生命周期范围小的 Denpendency 还是不理解，下面举个例子：
>
> ```java
> public class MainActivity extends AppCompatActivity {
>     public static final String TAG = "MainActivity";
>     @Inject
>     Cola cola1;
>     @Inject
>     Cola cola2;
> 
>     @Override
>     protected void onCreate(Bundle savedInstanceState) {
>         super.onCreate(savedInstanceState);
>         setContentView(R.layout.activity_main);
> 
>         DaggerBusinessman.create()
>                 .inject(this);
>         
>         cola1.drink();
>         cola2.drink();
>         
>         Log.e(TAG, "cala1=" + cola1);
>         Log.e(TAG, "cala2=" + cola2);
>     }
>     
> }
> ```
>
> Dagger 要实例注入 Cola 对象，但想要注入的两个 Cola 对象：`cola1` 、`cola2` 都是同一个实例，更通俗点讲，就是在 `MainActivity` 中（我们非常清楚 `MainActivity` 也是有生命周期的，它本身在执行了 `onDestory()` 后，会被 framework 层回收销毁掉），不管获取多少次，获取到的 `Cola` 对象都是同一个实例。
>
> 我们根据上一篇文章中的代码不变，来看一下这时会发生什么情况：
>
> <img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-05-17-234636.png" alt="image-20200518074629538" style="zoom:50%;" />
>
> 这时的情况显然是 `cola` 对象是两个不同的实例，也就表明当前 Dagger2 是注入几次就 **new** 几次 `Cola` 对象，然后赋值够 `cola1` 和 `cola2` 。
>
> 我们现在要处理的问题就是在 `MainActivity` 存活的时候，注入的 `Cola` 对象都是同一实例，这就叫 `Cola` 对象的生命周期与 `MainActivity` 相同，属于小范围的生命周期（相对于单例对象）。

那么在 Dagger2 中怎么控制 Dependency 的生命周期呢？

使用 `@Scope` 。

```java
@Target(ANNOTATION_TYPE)// ANNOTATION_TYPE 注解类型声明
@Retention(RUNTIME)
@Documented
public @interface Scope {}
```

`@Scope` 的 Target 是 `ANNOTATION_TYPE`  专职负责注解其他的注解，即元注解。

