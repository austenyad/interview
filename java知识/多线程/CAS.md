## CAS

英文全称是 **Compare-And-Swape**，中文叫做比较交换，它是一种思想、算法。

多线程的情况下，各个代码的执行顺序是不能确定的，所以为了保证并发安全，我们可以使用互斥锁。但锁有个一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起，这会导致线程上线文的切换和重新调度开销。而 CAS 的特点是避免使用互斥锁，当多个线程同时使用 CAS 更新同一个变量时，只有其中一个线程能够操作成功，而其他线程都会更新失败。不过和同步互斥锁不同的是，更新失败的线程并不会被阻塞，而是被告知这次由于竞争而导致的操作失败，但还可以再次尝试。



### CAS的原理

在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“**比较并交换**”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。

CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。**CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。**

详细操作: CAS 会提前假定当前内存值 V 应该等于值 A，而值 A 往往是之前读取到当时的内存值 V。那 CAS 就会把内存值 V 改成值 B，而值 B 往往是在拿到值 A 后，在值 A 的基础上经过计算而得到的。如果执行 CAS 时发现此时内存值 V 不等于值 A，则说明在刚才计算 B 的期间内，内存值已经被其他线程修改过了，那么本次 CAS 就不应该再修改了，可以避免多人同时修改导致出错。这就是 CAS 的主要思路和流程。

下面我们用图解和例子的方式，让 CAS 的过程变得更加清晰，如下图所示：

![image-20200811070550046](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-08-10-230552.png)

假设有两个线程，它们利用 CAS 来改变右边的变量的值，我们先看一下线程 1，假设它先执行，它期望当前值是 100，并且想改变为 150。在执行的时候它会去检查当前值是不是100，发现真的是100，所以可以改变成功，当完成后右边的值会从 100变成150。

![image-20200811071044829](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-08-10-231046.png)

如上图所示，假设现在刚刚轮到线程2来执行，它想把这个值从100 改成200，所以它希望当前值是100，实际上当前值已经是150了，所以它会发现当前值不是自己的期望值，所以并不会正真去把100变成200，也就是说整个操作没有效果，此次没有修改成功，CAS 操作失败。

当然接下来，线程2还可有有其他操作，这需要根据业务需求来决定，比如重试，报错或直接干脆跳过执行。

举个例子，在秒杀场景下，多个线程同时执行秒杀，只有一个能执行成功就够了，剩下的线程会发现自己的 CAS 操作失败了，其实说明兄弟线程执行成功了，也就是没有必要继续执行了，这就是跳过操作，所以业务逻辑不通就会有不同的处理方式，但无论后续怎么处理，之前的那一次 CAS 操作是已经失败了的。

### CAS 的语义

**等价语义**

```java
public class SimulatedCAS {
    private int value;

    public synchronized int compareAndSwap(int expectedValue,int newValue){
        int oldValue = value;
        if (oldValue == expectedValue){
            value = newValue;
        }
        return oldValue;
    }
}
```

在这段代码中有一个 compareAndSwap 方法，在这个方法里有两个入参，**第 1 个入参期望值 expectedValue**，**第 2 个入参是 newValue**，它就是我们计算好的新的值，我们希望把这个新的值去更新到变量上去。

你一定注意到了， **compareAndSwap 方法是被 synchronized 修饰的**，**我们用同步方法为 CAS 的等价代码保证了原子性。**





CAS 它的核心思想是，通过将内存中的值与指定数据进行比较，当这两个值一样时，才将内存中的值交换为新值，整个过程是具备原子性的。





### 循环 + CAS

### CAS 的缺点

##### 关于CAS 的 ABA 问题？

决定 CAS 操作中是否进行 swap 的判读是：**当前值** 和 **预期值** 是否一致，如果一致，就认为在此期间这个数值没有发生过变动，这在大多数情况下是没有问题的。

线程 I 使用 CAS 修改初始值为 A 的变量 X，那么线程 I 会首先去获取当前变量 X 的值，然后使用 CAS 操作尝试修改 X 的值为 B,如果使用 CAS 操作成功了，那么程序就一定正确吗？其实未必，这是因为有可能线程 I 获取变量 X 的值 A 后，在执行 CAS 前，线程 II 使用 CAS 修改了变量 X 的值为 B,然后又使用 CAS 修改了变量 X 的值为 A。所以虽然线程 I 执行 CAS 时 X 的值为 A，但是这个 A 已经不是线程 I 获取的 A 了。这就是 ABA 问题。

在某些业务场景下，我们想知道 **从上一个次看到这个值以来到现在，这个值是否发生过变化。** 例如，这个值假设 **从 A 变成了 B，再由 B 变回 A** ,此时，我们不仅认为它发生了变化，而且还发生了两次变化。

在这种情况下，我们使用 CAS 就看不到这两次变化，因为仅仅判断 "当前值与预期值是否一致" 就是不够的了。CAS 检查的并不是值有没有发生变化，而是去比较这个当前的值和预期是不是相等，如果变量的值从旧值 A 变成了新值 B 再变回旧值 A，由于最开始的 A 和 现在的值 A 是相等的，所以 CAS 会认为变量的值在此期间 **没有发生过变化**。所以，**CAS 并不能检测出在此期间是不是被修改过，它只能检查出现在的值和最初的值是不是一样。**



我们举一个例子：假设第一个线程拿到的初始值是 100，然后进行计算，在计算的过程中，有第二个线程把初始值改为200，然后紧接着又有第三个线程把 200 改回了 100。等到第一个线程去执行 CAS 的时候，它会比较当前的值是不是等于最开始拿到的初始值 100，此时会发现确实是等于 100，所以线程一就认为在此期间值没有被其他线程修改过，就理所当然的把这个 100 改成刚刚计算出来的新值，但实际上，在此过程中已经有其他线程把这个修改过了，这样就发生了 **ABA 问题**。

如果发生了 ABA 问题，那么线程就根本无法知晓在计算过程中是否有其他线程修改过，由于第一个线程发现当前值和预期值是相等的，所以就会认为在此期间没有线程修改过变量的值，所以它 **接下来一些操作逻辑，是按照在此期间这个值没有被修改过 的逻辑去处理的**，比如它可能会打印日志 ：“本次修改十分顺利”，但是它 **本应该触发其他逻辑**，比如当它发现了在此期间有其他线程修改了这个值，其实本应该打印的是：“本次修改过程中受到了干扰”。

###### 如何解决这个问题呢？添加一个版本号就可以解决

我们在变量值自身之外，在添加一个版本号，难么这个值的变化路径从 A --> B --> A 变成了 1A--> 2B-->3A，这样一来，就可以 **通过版本号来判断是否变化过**，这比我们直接去比较值一致更靠谱，所以这样的思路就可以解决 ABA 问题了。

ABA 问题的产生是因为变量的状态值产生了环形转换，就是变量值可以从 A 到 B,然后从 B到A。如果变量的值朝着一个方向转换，比如 A 到 B，B到 C，不够成环形，就不存在这个问题了。JDK 中的 **AtomicStampedReference** 类给每个状态值都配备了一个时间戳（版本号），从而避免了 ABA 问题的产生。





##### 自旋时间过长

由于单次 CAS 不一定能成功，所有 **CAS 往往是配合着循环来实现的** ,有的时候甚至是死循环，不停地进行重试，知道线程竞争不激烈的时候，才能修改成功。

可是如果我们的使用场景本身就是高并发场景，就是可能导致 CAS 一直操作不成功，这样的话，**循环时间就会越来越长**。而且在此期间，CPU 资源也是一直在被消耗，这会对性能产生很大的影响。所以这就要求我们，要根据时间情况来选择是否使用 CAS，在高并发的场景下，通常 CAS 的效率是不高的。

##### 范围不能灵活控制

通常我们执行 CAS 的时候，是针对某一个，而不是多个共享变量的，这个变量可能是 Integer 类，也有可能是 Long 类型，对象类型等等，但是我们不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合在一起，并不具备原子性。因此如果我们想对多个对象同时进行 CAS 操作并想保证线程安全的话，是比较困难的。

TODO 这里最好写一个例子

有个一个解决方案，那就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用 atomic 包中 AtomicReference 来吧这个对象整体进行 CAS 操作，这样就可以保证线程安全。

相比之下，如果我们使用其他线程安全技术，那么调整线程安全的范围就可能变得非常容易，比如我们用 synchronized 关键字时，如果想把更多的代码加锁，那么 **只需要把更多的代码放到同步代码块里面** 就可以了。