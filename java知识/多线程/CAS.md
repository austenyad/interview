## CAS

英文全称是 **Compare-And-Swape**，中文叫做比较交换，它是一种思想、算法。

多线程的情况下，各个代码的执行顺序是不能确定的，所以为了保证并发安全，我们可以使用互斥锁。但锁有个一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起，这会导致线程上线文的切换和重新调度开销。而 CAS 的特点是避免使用互斥锁，当多个线程同时使用 CAS 更新同一个变量时，只有其中一个线程能够操作成功，而其他线程都会更新失败。不过和同步互斥锁不同的是，更新失败的线程并不会被阻塞，而是被告知这次由于竞争而导致的操作失败，但还可以再次尝试。



### CAS的原理

在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“**比较并交换**”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。

CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。**CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。**

详细操作: CAS 会提前假定当前内存值 V 应该等于值 A，而值 A 往往是之前读取到当时的内存值 V。那 CAS 就会把内存值 V 改成值 B，而值 B 往往是在拿到值 A 后，在值 A 的基础上经过计算而得到的。如果执行 CAS 时发现此时内存值 V 不等于值 A，则说明在刚才计算 B 的期间内，内存值已经被其他线程修改过了，那么本次 CAS 就不应该再修改了，可以避免多人同时修改导致出错。这就是 CAS 的主要思路和流程。

下面我们用图解和例子的方式，让 CAS 的过程变得更加清晰，如下图所示：

![image-20200811070550046](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-08-10-230552.png)

假设有两个线程，它们利用 CAS 来改变右边的变量的值，我们先看一下线程 1，假设它先执行，它期望当前值是 100，并且想改变为 150。在执行的时候它会去检查当前值是不是100，发现真的是100，所以可以改变成功，当完成后右边的值会从 100变成150。

![image-20200811071044829](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-08-10-231046.png)

如上图所示，假设现在刚刚轮到线程2来执行，它想把这个值从100 改成200，所以它希望当前值是100，实际上当前值已经是150了，所以它会发现当前值不是自己的期望值，所以并不会正真去把100变成200，也就是说整个操作没有效果，此次没有修改成功，CAS 操作失败。

当然接下来，线程2还可有有其他操作，这需要根据业务需求来决定，比如重试，报错或直接干脆跳过执行。

举个例子，在秒杀场景下，多个线程同时执行秒杀，只有一个能执行成功就够了，剩下的线程会发现自己的 CAS 操作失败了，其实说明兄弟线程执行成功了，也就是没有必要继续执行了，这就是跳过操作，所以业务逻辑不通就会有不同的处理方式，但无论后续怎么处理，之前的那一次 CAS 操作是已经失败了的。

### CAS 的语义

**等价语义**

```java
public class SimulatedCAS {
    private int value;

    public synchronized int compareAndSwap(int expectedValue,int newValue){
        int oldValue = value;
        if (oldValue == expectedValue){
            value = newValue;
        }
        return oldValue;
    }
}
```

在这段代码中有一个 compareAndSwap 方法，在这个方法里有两个入参，**第 1 个入参期望值 expectedValue**，**第 2 个入参是 newValue**，它就是我们计算好的新的值，我们希望把这个新的值去更新到变量上去。

你一定注意到了， **compareAndSwap 方法是被 synchronized 修饰的**，**我们用同步方法为 CAS 的等价代码保证了原子性。**





CAS 它的核心思想是，通过将内存中的值与指定数据进行比较，当这两个值一样时，才将内存中的值交换为新值，整个过程是具备原子性的。





### 循环 + CAS

### CAS 的缺点

##### 关于CAS 的 ABA 问题？

决定 CAS 操作中是否进行 swap 的判读是：**当前值** 和 **预期值** 是否一致，如果一致，就认为在此期间这个数值没有发生过变动，这在大多数情况下是没有问题的。

线程 I 使用 CAS 修改初始值为 A 的变量 X，那么线程 I 会首先去获取当前变量 X 的值，然后使用 CAS 操作尝试修改 X 的值为 B,如果使用 CAS 操作成功了，那么程序就一定正确吗？其实未必，这是因为有可能线程 I 获取变量 X 的值 A 后，在执行 CAS 前，线程 II 使用 CAS 修改了变量 X 的值为 B,然后又使用 CAS 修改了变量 X 的值为 A。所以虽然线程 I 执行 CAS 时 X 的值为 A，但是这个 A 已经不是线程 I 获取的 A 了。这就是 ABA 问题。

ABA 问题的产生是因为变量的状态值产生了环形转换，就是变量值可以从 A 到 B,然后从 B到A。如果变量的值朝着一个方向转换，比如 A 到 B，B到 C，不够成环形，就不存在这个问题了。JDK 中的 AtomicStampedReference 类给每个状态值都配备了一个时间戳，从而避免了 ABA 问题的产生。

##### 自旋时间过长

##### 范围不能灵活控制





