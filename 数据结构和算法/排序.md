# 排序

### 如何评价、分析一个排序算法？

#### <span style= "color:#FA891A">排序算法的执行效率</span>

对于排序的算法执行效率，一般会从这几个方面进行衡量：

##### 1. 最好情况、最坏情况、平均情况时间复杂度

平均时间复杂度 ===> 加权期望时间复杂度 ---> 概率知识 ---> 相对来讲这种分析方式比较复杂。

n 个数有 n 个排列方式

另一种分析平均时间复杂度的思路是通过 **有序度** 和 **逆序度** 两个概念分析。

**有序度** 数组中具有有序关系的个数，对于一个完全有序的数组它的有序度是 **n*(n-1)/2** ，称这种有序度为 **满有序度**，**逆序度** 的定义正好相反。

逆序度 = 满有序度 - 有序度

排序的过程就是增加有序度，减少逆序度的过程，最后到达满有序度，即排序完成。

##### 2. 时间复杂度的系数、常数、低阶

##### 3.比较次数和交换次数

#### <span style= "color:#FA891A">排序算法的内存消耗</span>

内存消耗可以通过空间复杂度衡量，不过针对排序算法的复杂度，可以引入 --- **原地排序**。原地排序就是特指空间复杂度是 O(1) 的排序算法。比如：冒泡排序、插入排序、选择排序 等。

#### <span style= "color:#FA891A">排序算法的稳定性</span>

如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。

根据这个排序算法可分为 **稳定的排序算法** 和 **不稳定的排序算法**



## 冒泡排序

## 插入排序

## 选择排序





## 归并排序（merge sort）

## 快排 （quick sort）

如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。





### 归并排序与快速排序的区别

两者都用的是分治思想、递推公式和递归代码也非常相似，那它们的区别在哪里呢？

归并排序的处理过程是**由下而上**的，先处理子问题然后在合并。而快速排序正好相反，它的处理过程是**由上而下** ，先分区，再处理子问题。归并排序虽然是稳定的、时 间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。

归并之所以 是非原地排序算法，主要原因是合并函数无法在原地执行。

快速排序通过设计巧妙的原地分 区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

**排序算法的时间复杂度和空间复杂度分析** 重点

