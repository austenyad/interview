理解简单的一个 helloworld 程序是怎样运行的

* 在 Unix 系统上，从源文件到目标文件的转化是由 编译器驱动程序 完成的。

liux> gcc -o hello hello.c

上面，GCC 编译器读取源文件 hello.c ,并把它翻译成可执行文件 hello。这个翻译过程由四个阶段的程序（预处理、编译器、汇编器和链接器）一起构成了 编译系统（compilation system）。<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-05-31-162823.png" style="zoom:50%;" />

\1. 预处理阶段。预处理器（cpp）根据已字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 的第一行的 #include<stdio.h> 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到另一个 C 程序，通常以 .i 作为文件扩展名。

\2. 编译阶段。 编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个 汇编语言程序。该程序包含 函数 main 的定义，如下所示：

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-05-31-162825.png" style="zoom:50%;" />



定义中 2-7 行的每条语句都以一种 文本格式 描述了 一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输入语言。例如，C 编译器 和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。

\3. 汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器指令，把这些指令打包成一种叫做 可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。如果我们再文本文件中打开 hello.o 文件，将是一堆乱码。

4.链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的 标准 C 库的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。连接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为 可执行文件），可以被加载到内存中，由系统执行。

#### 了解编译系统如何工作的益处：

\1. 优化程序性能

\2. 理解链接时出现的错误

\3. 避免安全漏洞

#### 1.4 处理器读取并解释存储在内存中的指令

此刻，hello.c 源程序已经被编译系统翻译成了可执行目标文件，并存放在磁盘上。要想运行可执行文件，我们需要将它的文件名输入到 **shell** 的应用程序当中：

```shell
linux> ./hello
hello,world
linux>
```

**Shell 是一个命令行解释器** ,它输入一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，将它加载并运行这个文件。所以在此例中，shell 将加载并运行 hello 程序，然后等待程序终止。hello 程序在屏幕上输出它的消息，然后终止。shell 随后输出一个提示符，等待下一个输入命令。

##### 1.4.1 系统的硬件组成

为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组成。

1. 总线

贯串整个系统的一组电子管道，称为 总线。

被设计成传送定长**字节块** ，也就是 字 （word）。

2. I/O 设备

I/O 设备是系统与外部世界的联系通道。我们的示例系统包含四个 I/O 设备：

3. 主存

主存 是一个临时储存设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组 动态随机存取存储器（DRAM）芯片组从的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有唯一的地址（数组索引），这些地址是从 0 开始的。

4. 处理器

中央处理单元（CPU）,简称 处理器，是解释（或执行）存储在主存中的指令的引擎。处理器的核心是一个大小为一个字的储存设备（或寄存器），称为 **程序计数器（PC）**。在任何时刻，PC 都是执行主存中的某条机器语言指令（即含有该指令的地址）。

从系统通电开始，直至系统断电，处理器一直在不断地执行 程序计数器 指向的指令，再更新程序计数器，使其执行下一个指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由 **指令集架构** 决定的。在这个模型中，指令按照严格是顺序执行，而执行一条指令包含执行一系列步骤。处理器从程序计数器执指向的内存读取指令，解释指令中的位？，执行该指令的简单操作，然后更新 PC，使其执行下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的操作并不多，它们围绕 **主存**、**寄存器文件（register file）**和 **算术/逻辑单元（ALU）**进行。**寄存器文件** 是一个小的储存设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。AUL 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行的这些操作。

* 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
* 存储：从寄存器复制一个字节或一个字到主存的某个位置，以覆盖这个位置上原来的内容。
* 操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器原来的内容。
* 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。

处理器看上去它的指令集架构的简单实现，但是实际上现代处理器是用来非常复杂的机制来加速程序执行。因此，我们将 **处理器的指令集架构** 和 **处理器 微体系结构** 区别开来：

处理器指令集架构：描述的是每条机器代码的指令效果；

微体系结构：描述的是处理器实际上是如何实现的。

##### 1.4.2 运行 hello 程序

运行到底发生了什么？

初始时，shell 程序执行它的指令，等待我们输入一个指令。当我们在键盘上输入字符串 `./hello` 后，shell 程序将字符逐一读入寄存器，再把它放入到内存中，如图

当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 ”hello,world\n“ 。

利用 **直接存储器（DMA）** 存取技术，数据可以不通过处理器而直接从磁盘到达主存。

一旦目标文件 hello 中的代码和数据被加载到内存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 ”hello,world\n“ 字符串的字节从主存复制到寄存器文件，在从寄存器文件复制到显示设备，最终显示到屏幕上。

#### 1.5 高速缓存的至关重要







#### 



