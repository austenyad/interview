 ![image-20200701161850421](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-081852.png)

![image-20200701162011812](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-082015.png)

![image-20200701162328745](/Users/austen/Library/Application Support/typora-user-images/image-20200701162328745.png)

传输层 ：解决这两个进程是怎么样通信的。跨设备的进程通信或者说是跨网络的。

哪到底是端与端之间的那个进程来进行通信呢？

端口是什么是用来标记不同的计算机里面需要进行网络通信的进程。

* 使用端口（Port ）来标记不同的网络进程，一般是使用16个比特位来表示的（0~65535）

  



![image-20200701162919864](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-082921.png)

![image-20200701163041415](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-083307.png)

传输层主要有两种协议：TCP UDP 

### ![image-20200701163326783](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-083329.png)UDP（User Datagram Protocal，用户数据报协议） ：

![image-20200701170442105](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-090444.png)

图- UDP 的首部：

1. 本机要进行网络通信的进程端口号
2. 目标机器正在运行的网络进程端口号
3. 数据报的长度
4. 校验和  

总共也就 8 个 字节：**很小**

数据报：

* 无连接的协议
* 不能够保证可靠的交付数据
* 面向报文传输的：这个报文就是应用层所传递过来的数据，UDP 协议不会做任何处理，直接把它塞进UDP 协议的数据里面。

![image-20200701170956668](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-090958.png)

* 没有 **拥塞控制** ：不会感知到网络是否拥塞，不管网络是否发生拥塞，它都会尽量的把这个数据交付出去。然后就完了。
* 首部开销很小



# TCP (Transmission  Control Protocal，传输控制协议)

非常复杂的协议



![image-20200701171730009](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-091733.png)

TCP 协议也是位于 IP 数据报里面的协议，它也分成 TCP 首部，以及 TCP 数据报的数据 两个部分组成。

* 面向连接的协议
* 连接有两端（是点到点的通信）
* 提供可靠的传输服务
* 全双工的通信协议 ：什么是全双工—— 比如说我和你打电话，我和你都可以在这个电话的连接里面进行对话——全双工，就是两端都可以往这个连接里面发送数据，或者是接受数据。
* 面向字节流的协议：UDP 面向用户数据报的协议 ？？ 字节流 和 数据报 有什么区别？ —— 流入进程或流出进程的字节序列，我们知道 传输层的数据是应用层传输下来的，数据是一块一块的，在 TCP 里面它不把它看做是一块数据，而是把它看做是一系列的、一整串的字节流。也就是传输数据的时候是一个字节一个字节处理的， 所以在 TCP 里面就可能取出数据里面的某一段 来进行传输，而剩下的数据则把它放到第二个数据报文里面，所以就会对应用层传递过来的数据进行合并和拆分。

## TCP 协议的首部：

![image-20200701173449767](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-093451.png)

### 序号

![image-20200701180153257](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-100154.png)

### 确认号



![image-20200701180048386](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-100050.png)

我期望收到的下一个 TCP 数据报  的数据的首字节序号，**确认号**就是配合这 **序号**来一起使用的。 

### 数据偏移

![image-20200701181053998](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101056.png)

### TCP 标记

![image-20200701181145029](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101147.png)

![image-20200701181249113](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101250.png)

FIN 当前连接的工作已经完成了，我希望释放这个连接。

### 滑动窗口

![00](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101554.png)

举个例子：当 **确认号 ： 501** ，**窗口值：1000** ，那么也就是说从 501 到 1500 这么多个字节数据都是可以接收的。

### 紧急指针

![image-20200701181841080](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101842.png)

### TCP 选项

![image-20200701181923136](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101925.png)

## TCP 可靠协议的原理

![image-20200701191144616](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-111146.png)

超时定时器——每发送一个消息，都设置一个定时器。

![image-20200701191205859](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-111207.png)

是在停止等待协议上改造的；

连续 ARQ 协议 ARQ (Automatic Repeat reQuest，自动重传请求)

**滑动窗口、累计确认**



![image-20200701191839295](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-111842.png)

![image-20200701191901674](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-111903.png)

![image-20200701221430356](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-141432.png)



23 就是确认号的概念



![image-20200701221626268](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-141628.png)

![image-20200701221825383](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-141832.png)

现在滑动窗口中的数据发送出去了，过了一段时间25、27 字节 确认号 已经收到了，但23、24这个确认号还没有收到，那么假如说这个超时时间已经到来了，23，24还没有收到确认消息，这个时候即使25，27收到了，我们还是需要从23开始重传这个消息的，就是因为23，24这个确认好没有收到，等到超时时间到了就需要从23发送重新发送消息。这里注意一点是没有按序收到这个确认号的话。这就是 TCP 协议的可靠传输。

从上面发现，这个可靠性传输它是效率并不高

选择重传：

* 需要选择重传的字节
* 每个字节都有一个唯一的32位的序号

![image-20200701225431237](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-145432.png)

需要重传的边界

![image-20200701225620129](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-145622.png)

重传的数据它是一个边界，存储在 TCP 选项中的序号并不是只重传某一个字节，而是指一个范围。

* 只有 TCP 有流量控制，流量控制是通过TCP首部的滑动窗口来实现的，
* 什么有流量控制？是因为，接受方希望发生方，发生数据的时候慢一些，接受方不能，那么快的去接受很大的流量，那么这个时候接受方希望发发送方发送数据的时候慢一些。





* 流量控制指 发送方发送速率不要太快
* 流量控制是用滑动窗口来实现的

![image-20200704214254272](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-134302.png)

![image-20200704215405499](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-135407.png)

接受方可以调整窗口来告诉接受方我当前还可以接受多少的数据，那么就通过这个窗口的大小来控制接受流量大小的控制。



那么再接着说，如果 接收方 处理完发生过来的消息，那么这个时候接受方就可以想发送方发送一个消息当前我的窗口可以接受到 1000 个数据，也就是说接收方它调整了窗口的大小，并且告诉发送方。发送方在接受到这个消息之后它知道接收方可以接受消息了，因此哪，它就是会继续进行数据的封装，并且把数据发送给接受方 。那么这个就是接受方通过调整窗口的大小通知发送方继续进行数据的发送。

![image-20200704220403856](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-140405.png)

 这里我们假设 接受方在发生它的窗口调整为 1000 的这个消息，消息在网络的传输过程当中，发生了丢失。那么这种情况下面就会引发双方死锁等待的情况。因为在这个时候 接受方 它还以为 这个接受方的窗口为 0 ，一直在等待接受方的窗口调大，以进行新的数据的发送。  接着看接受方，那么接受方已经把自己窗口调大的消息发送给了发送方，那么理论上发送方在接收到这个消息后呢的，会把新的数据发送给我，因此接受方也会一直的等待， 所以 就会发生 接受方和发送方 都在相互等待，形成死锁的状态。

这里可能就有疑问了，TCP 不是可靠的传输吗？那么这个消息为什么会丢失呢？

是因为我们在讲 TCP 的可靠传输的时候，主要是从数据的角度去考虑的，也就是说对于 TCP 可靠传输都的对这个数据的确认，比如说里面的 确认号 ，以及确认号都是用来对数据的字节来进行确认的。那么对于特殊的消息，比如上面的 窗口大小调整的消息，其实是不可靠的，没有超时重传的机制的，那么就会导致这个消息丢失，那么就会引发 发送方 和 接受方 相互等待状态。

那么上面的情况怎么解决呢？



坚持定时器！！！（我们上面还学到  超时定时器）

这个定时器它主要是解决这个死锁的局面的。

* 发送方当接受到 窗口大小为0 的这个消息时，就会启动 坚持定时器
* 坚持定时器，每隔一段时间就会向 接受方 发送一个 **窗口探测报文**

通过这个 窗口探测报文 它就会询问到 对方 的窗口有没有增大，那么这样子就一个解决这个死锁的局面。如果调大的化，就会继续发送数据给对方了。



## TCP 协议的拥赛控制

把网络想象成公路的拥塞

### 拥塞的根源

![image-20200704225534076](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-145535.png)

从根本上来讲，网络对硬件设备的性能要求大于可用资源，因此就会导致拥塞的发送

 

### 拥塞控制和流量控制区别

* 流量控制考虑的是 点对点的通信控制
* 拥塞控制考虑的是整个网络，是全局性的考虑（它会感知到网络有没有发生拥塞，或者是发生网络拥塞的时候的解决方法）

拥塞控制是一个很庞大的问题，因为它考虑的是整个网络，并且对于拥塞控制很难有最优解的，所以在这里先有一个简单的认识就行。

### 拥塞控制

如果说需要进行拥塞控制，那么首先它需要有个方法去判断网络是否发送拥塞，那么这个方法很简单很粗暴：

发送的报文超时则认为是拥塞，就认为网络发生了拥塞。（必要不充分条件）

![image-20200704231215044](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-151216.png)

#### 拥塞控制的两个算法

1. 慢启动算法

* 有小到大的增大发送数量
* 每收到一个报文的确认，就加一

比如：第一的时候发送的 1个报文 ，然后这个报文收到确认之后就加一，因此第二次就会发送 2 个报文，第三次就会发送 4 个报文，收到确认，再下一次就发送 8 个报文。

![image-20200704232006120](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-152007.png)

很显然，慢启动算法发送报文的数量，呈指数级增长，当数量达到 **慢启动阈值**， 就不增长了。到达这个阈值之后，就会进行 下面的第二个算法。

2.  拥塞避免算法

* 维护一个拥塞窗口的变量（这个变量是大于上面的 **慢启动阈值** 的）
* 只要网络不拥塞，那么就试探着把这个拥塞窗口值调大

![image-20200704232601748](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-152603.png)，

比如：慢启动到达了阈值，假如说是 16 ，这时候就会启动拥塞避免算法，对于这个拥塞避免算法它会试探着把这个拥塞窗口调大，如果说发送 16 个报文都是可以确认的，那么下一个它就会发送 17 个报文，如果说没有发生超时，那么下一次 18 个报文，如果还没有发生拥戴，那么把拥塞窗口调成 19 。它会一直试探着把这个拥塞窗口调大，知道发生拥塞，这个就是拥塞避免算法。这个算法可以保证在网络不发生拥塞的前提下，更多的去发送数据。

![image-20200704233359212](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-04-153400.png)

## TCP 连接的建立（TCP 连接的 三次握手）

必须知道 TCP 标记的内容

![](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-01-101147.png)

![image-20200705001328345](/Users/austen/Library/Application Support/typora-user-images/image-20200705001328345.png)

### 连接建立的过程

![image-20200705111902021](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-05-031904.png)

发送方需要与接收方建立连接

1. 发送方 发送第一次报文，SYN = 1（表示的是连接请求报文），seq = x（序列号），这个报文是第一次握手

2. 接收方在接受到这个报文之后，会被动的打开 TCP 连接 ，同时它也会发出一个报文，这个报文是第二次握手

第二个报文中的关键信息是 SYN = 1（表示连接请求报文），ACK = 1（表示对序列号的确认），ack = x + 1，（表示的是确认号，表示说我期望收到 x+1 的序列号的值），seq = y （序列号，同时这个报文也会携带自己的序列号 ），这些就是第二次握手所携带的信息，是由接受方所发送出来的，也就是这个被动连接的这一方所发出来的。

3. 那么在发送方 接受到 由接受方所发送的消息后，它也会进行一个回应，这个回应称为第三次握手。这个报文也有一些关键信息：ACK = 1（表示这个报文的确认号是生效的），ack = y + 1 （表示说我期望收到你的序号为 y+1 的数据），seq = x + 1（并且也会同步一个自己的序列号为 x+1,表示说当前我发送数据的序列号为 x+1 ）,这个就是第三次握手中关键的信息。

通过这三次握手，双方的 TCP 连接就建立起来了。 

#### 为什么发送方要第三个确认报文？

* 已经**失效的连接请求报文**传送个对方，**引起错误**：避免已经失效的连接请求报文传送到对方，以引发不应该出现的错误。

![image-20200705114457499](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-05-034458.png)

假设第一次握手的报文在网络中，传输了很久，才到达接受方，那么因为传输了很久，所以发送方很久都没有收到确认消息 ，那么发送方就会认为这个报文已经超时了 ，所以发送方就会发送第二次，再假设第二次发送的报文很快就到达了对方，那么接受方在接受到这个请求报文之后就会进行回应，并且建立起它们之间的连接，这里面因为有第二次的存在，所以双方建立起连接了。那么对于第一请求就是失效的请求报文了，因为它的功能已经被第二次发送的请求所完成了 。

如果说两次握手就建立起这个连接的话，那么失效的请求也会建立起这个连接，因为只要这个接受方回应了，就表示说这个连接已经建立了 。那么就会建立两个 TCP 连接的这个情况，这个情况是错误的。那么就是说这个两次握手建立连接就会引发这个连接错误。 

发送方已经进行了第三次握手 ，因此发送方 对于第二次这个确认消息，它会忽略掉，并不会进行任何的操作，就是后面到达这个确认，发送方并没进行三次握手，这样子就避免了两次握手引发的这个错误，这就是三次握手的作用：避免失效的请求到达对方，并且引发不应该有的错误。



## TCP 连接的释放（TCP 连接的四次挥手）



![image-20200705120250635](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-05-040252.png)

在 发送方 和 接受方连接正常的情况下，它们直接一直是可以进行数据的传输的。

这个时候假设数据传输完成了，这个时候发送方 或者说 接受方 就可能 TCP 连接的释放。这里面我们假设，发送方要进行主动连接的释放。

1. 发送方首先会发送一个特殊的报文，这个报文中 TCP 标记：FIN = 1（表示我需要释放这个连接）,这个就称之为第一次挥手。那么发送方在发送这个报文之后就会进入 FIN-WAIT-1 状态，这里的表示连接等待的第一状态。
2. 那么接受方 在接受到这个报文之后它就知道了发送方原来是要结束这个连接了。因此，接受方也会发送一个报文进行确认，这里面确认的是你发送给我的这个序列号我已经收到了，表示说你的释放请求已经被我收到了 ，并且我对你这个消息进行了一个确认，那么这个报文就是第二次挥手。这个是由接受方所发送出来的。
3. 发送方，也就是主动 请求释放连接的这一方，它收到第二个报文之后，它就进行入了第二个状态 FIN-WAIT-2，这个状态称之为 断开连接等待的第二个状态。  对于接受方来说，只要第二个报文发出去以后，它就进入了关闭等待状态（CLOSE-WAIT）。那么对于接受方的这个关闭等待状态，其实在接收方在这个状态之后它还是可以 进行这个数据的发送的，那么这里面主要是因为 这个释放连接的请求是由发送方发出来的，发送方发出来表示说它的数据已经传输完成了，但是对于这个被动释放的接受方，它可能这个数据还没有发送完成，所以在这个关闭等待状态，接受方还可以继续的进行数据的发送，那么等到接收发发送数据完成之后，它又会发送一个数据报文，这个报文就是携带 FIN 这里标记的报文，表示说我也可以进行这个连接的释放了，并且这里面还会携带一个 ACK，重复的对刚才的第一个报文进行确人，那么这个哪就是属于第三次挥手。
4. 发送方 在接受到第三个报文之后呢，也就是进行了第三次挥手之后，它又会发出一个确认，确认说你发送给我的连接释放的信号我已经收到了，那么现在我们就一起把这个连接释放掉吧。那么这个就是第四次挥手报文的意思。对于接收方来说，从第三次报文到第四次报文之间的状态属于最后确认的状态（LAST-ACK），它是为了确认发送方已经接收到连接释放的报文的，那么这个状态称为最后确认的状态。

这个时候，发送方在进入第四次挥手之后呢，它就会进入一个特殊的状态，我们称为之为 时间等待的状态，这里面有一个等待计时器，发送方会在这个时间等待状态里面等待一段时间，确保这个时间里面没有出现任何的问题，然后才进入正真的连接关闭的状态。这里是属于发送方即主动请求结束连接的这一方，会有的一个特殊状态，这个状态是 TIME-WAIT 状态。主动释放连接的这一方它有一个等待计时状态，那么只有在等待计时之后，才会进入关闭状态，那么对于接受方它就不一样了，它只要在**最后确认状态**之后它就进入了关闭状态。

这个就是四次挥手的过程，它是 TCP 连接释放的过程。

### 等待计时器

![image-20200705134115745](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-07-05-054118.png)

1. 超时计时器
2. 坚持计时器
3. 等待计时器

对于等待计时器它会等待 2倍的 MSL 时间。

那么我们知道对于 TCP 每一个连接它都会占用一个端口，如说在这个等待的过程当中，你想起另外一个网络的进程复用这个端口的话，可定是不行的，因为在等待的时候这个端口还是被占用的，它会提示说你的端口被占用，那么就是说在这个等待计时器里面 TCP 是不会释放这个连接的，也就是它不会释放这个端口，只有在等待计时器结束之后它才会释放这个端口。

如果说你平时在进行 TCP 编程的时候，你会发现，如果说你主动的释放了这个连接，你想马上复用这个端口的话，那么其实是不行的，就是因为主动释放的这一方它会进入等待计时器的状态，在这个状态里面它是不会释放这个端口的，只有在这个计时器结束之后它才会释放这个端口。如果说你是主动释放连接的一方，你只用等待 2 倍的 MSL 的时间呢，才可以重复的new这个端口。

#### 为什么需要等待计时器？为什么需要等待 2MSL?

观察一下，只要发送方发送了第四次挥手这个报文之后，它就进入了这个等待的状态。

* 在进入等待状态后，它其实最后一个报文是没有得到确认的
* 等待计时器主要是为了，最后发送方所发送的 ACK 可以正常的到达对方，那么这个 2MSL 是这个报文在网络中存活最长的这个时间
* 如果说 在 2MSL 接受方没有收到，那么接受方就会认为说我发出的第二个报文，也就是第三次挥手，可能没有到达对方，因此它就会重新的把 FIN = 1,ACK = 1 的报文重新的发送个发送方，也就是重复的进行第三次挥手的步骤，那么发送方接受到这个报文就知道了原来我发送的第四个挥手的报文对方并没有接收到，对方也就是接受方重新发送了连接释放的请求，因此发送方又会重新的构造一个新的报文，再次进行第四次挥手，这个就是等待计时器的作用。

1. 主要是为了确保发送方发送的第四个挥手的报文，可以正确的到达对方，如果没到达的话，接受方就会重新的发送第三次挥手的报文，以正确的结束这一次连接。
2. 当前连接的所有报文都已过期

因为最有一个报文都等待了 2 倍的 MSL ，那么对于其他报文肯定也是超过 2 MSL 时间，所以对其他报文来说肯定都是已经过期的报文了，所以这样子就可以确保当前连接所有报文都已经过期了，这个是等待计时器的第二个作用。









