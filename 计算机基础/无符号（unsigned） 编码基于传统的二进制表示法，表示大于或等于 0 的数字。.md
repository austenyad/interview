**无符号（unsigned）** 编码基于传统的二进制表示法，表示大于或等于 0 的数字。

**补码（two's-complement）** 编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。

**浮点数（floating-point）** 编码是表示实数的科学计数法的以2为基数的版本。

GUN 编译器套装（GUN Compiler Colletion,**GCC**）可以基于不同的命令选项，依照多个不同版本的 C 语言规则来编译程序。例如，根据 ISO C11 来编译程序 prog.c ，我们就可以使用命令行：

`linux> gcc -std=c11 prog.c`

编写选项 `-ansi` 和 `-std=c89` 是一样的 —— 会根据 ANSI 或者 ISO C90 标准来编译程序。

## 2.1 信息储存

大多数计算机使用 8 位字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。

机器级程序将内存视为一个非常大的数组，称为 虚拟内存（Virtual memory）。

> C 指针提供了 引用数据结构（包括数组）的元素机制。与变量类似，指针有两个方面：值 和 类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储的类型（比如整数或者浮点数）。

### 2.1.1 十六进制

**hexadecimal** — **hex**

一个字节的值域为 00 ~ FF 。

### 2.1.1 字数据大小

<<<<<<< HEAD
每个计算机都有一个字长（word size）,指明指针数据大小的标称大小（nominal size）。因为虚拟内存地址空间的大小就是有字长决定的。一个字长为 *w* 位的计算机，虚拟地址的范围为 0 ~ 2 ^ *w*  - 1，程序最多访问 2 ^ *w* 个字节。

大多数 64 位机器也可以运行 32 位 机器编译的程序，只是一种向后兼容。举例：

`linux> gcc -m32 prog.c` 32 或 64 位均可

`linux> gcc -m64 prog.c` 只能 64 位

我们将程序称为 32 位程序 或 64 位程序 时，区别在于该程序是如何编译的，而不是其运行的机器类型。



### 2.1.3 寻址和字节顺序

> C语言 
>
> 1. 使用 **typedef** 来命名数据类型
>
> **typedef** 提供了给数据类型命名的方式。这能够极大地改善代码的可读性，因为深度嵌套的类型声明很难读懂。
>
> `typedef int *int_pointer;`
>
> `int_pointer ip;`
>
> 将类型 “int_pointer” 定义为一个指向 int 的指针，并且声明了一个这种类型的变量 ip。我们还可以将这个变量直接声明为：
>
> `int *p;`
>
> 2. 使用 **printf** 格式化输出

### 2.1.4 表示字符串

1. 十进制数字 x 的 ASCII 码正好是 0x3x。

   例如：1 -> 0x31,2->0x32

2. 终止字节的十六进制表示 0x00。

### 2.1.6 布尔代数

**真** 1	**假** 0

布尔运算 `~` 对应逻辑运算 NOT「非」。

布尔运算 `&` 对应逻辑运算 AND「与」。

布尔运算 `|` 对应逻辑运算 OR「或」。

布尔运算 `^` 对应逻辑运算 「异或」。同为假，不同为真。

布尔运算扩展到 **位向量的运算** ，位向量就是固定长度为 *w*、由 0 和 1 组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假设 a 和 b 分别表示位向量。

举个例子,假设 `w = 4` ,`a = [0110]`,`b = [1100]`。那么 4 种运算 `a&b` 、`a|b` 、`a^b` 、和 `~b` 分别得到一下结果：

![image-20200606224803273](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-06-144806.png)

乘法对加法分配律，写为 `a*(b+c)=(a*b)+(a*c)`

布尔运算 `&` 与 `|` 的分配律

`a&(b|c) = (a&b)|(a&c)`

`a|(b&c) = (a|b)&(a|c)`

### 2.1.7 C 语言中的位级运算

0x000000000000000a

### 2.1.8 C 语言中的逻辑运算

C 语言中还提供一组逻辑运算符 `||` 、`&&`、`！` 分别对应于命题逻辑中的 OR、AND 和 NOT 运算。

**逻辑运算** 很容易和 **位运算** 相混淆，但是他们的功能是完全不同的。

逻辑运算：非 0 参数都是 TRUE，参数 0 表示 FALSE。

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-06-160033.png" alt="image-20200607000027968" style="zoom:50%;" />

习题：2.15

### 2.1.9 C 语言中的位移运算

C 语言还提供一组位移运算，向左或者向右移动位模式。

w : 表示一个数二进制有 w 位。

`<<` 左移 ：比如 `x << k` ，也就是，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。

移位量应该是一个 0 ~ w - 1 之间的值。移位运算是从左至右可结合的，所以 `x << j << k` 等价于 `(x << j) << k。`

`>>` 右移：

一般而言、机器支持两种形式的右移：逻辑右移和算术右移。

逻辑右移在左端不 k 个 0。

算术右移是在左端补 k 个最高有效位的值。

例子：操作两个 8 位是数

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-06-162724.png" alt="image-20200607002719961" style="zoom:50%;" />

**大多默认是 算术右移，另外对于无符号数右移是逻辑的。**

> Java 语言对于如何进行右移有明确的定义
>
> `x >> k` 算术右移
>
> `x >>> k` 逻辑右移

> ### 移动 k 位这里的 k 很大
>
> w 位组成的数据，如果移动 k >= w 为结果会如何呢？
>
> ```c
> int lval = 0xFEDCBA98 << 32
> int aval = 0xFEDCBA98 >> 36
> unsigned uval = 0xFEDCBA98u >> 40
> ```
>
> 在许多机器上，当移动一个 w 位的值时，位移指令只考虑位移量低于 log2w 位，因此实际上位移量就是通过计算 `k mod w` （余）得到的。例如，当 `w = 32` 时，上面三个位移预算分别是移动 0、4、8 位 得到的结果：
>
> ```c
> 
> 
> 
> ```
>
> 不过这种行为对于 C 程序来说没有保证的，所以应该保持位移量小于待待移位的值的位数。
>
> Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。

**C 语言中 加法优先级大于位运算，当你拿不准时请加上括号！**
=======
每个计算机都有一个字长（word size）,指明指针数据大小的标称大小（nominal size）。











2.6 习题答案：带图片

### 2.1.6 布尔代数简介

布尔运算 `~` 对应与逻辑运算 NOT。

布尔运算 `&` 对应于逻辑运算 AND。

布尔运算 `|` 对应于逻辑运算 OR。

布尔运算 `^` 对应于逻辑运算 。














>>>>>>> 6f219f97568c1c127efba8f11404132a7752843d



